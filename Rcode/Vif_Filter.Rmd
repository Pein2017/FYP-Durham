---
title: "DealingWithData"
author: "Peian"
date: '2022-07-09'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
source( "data_loader.R" )
temp = data_loader( Hour = 361)
data19 = temp$data_19
ac19 = temp$ac_19
# removing  "pump.outlet"
data19 = data19[ , -which(names(data19) == "O2.in.offgas.." ) ] 
nzv = nearZeroVar(data19, saveMetrics= TRUE)
nzv = nearZeroVar(data19)
data19 = data19[, -nzv]
data19 = data19[,-c(53:59)]
```

### Selecting the data closest to real data
```{r , echo = FALSE}
set.seed(825)
index = vector( len = nrow(ac19) )
for ( i in 1:nrow(ac19) )
{
  index[i] = which( abs( ac19$EFT[i] - data19$EFT_H ) == min( abs(   ac19$EFT[i] - data19$EFT_H) ) )
}
trueData19 = data19[index,]
train = data19[-index , ]
test = data19[index,]
```

```{r}
vifSelection = function( data, removeCols = c(1) , vifThres =30 , subsets = NULL )
{
  library(car)
  # if ( is.null(removeCols) ) removeCols = c()
  nm = names(data)
  p = ncol( data )
  run = 1
  while ( run < p )
  {
    if ( is.null( subsets) )
    {
      reg1 = lm( interpolated_acetic ~., data = data[,-removeCols])
    }
    else
    {
      reg1 = lm( interpolated_acetic ~., data = data[subsets, -removeCols])
    }
    vif1 =  vif(reg1) 
    vif1 =  sort( vif1 , decreasing = TRUE)
    removeTarget = vif1[1]
    if ( removeTarget > vifThres )
    {
      addCol = which( nm == names(removeTarget) )
      removeCols = c( removeCols,  addCol )
      run = run + 1
    }
    else break
  }
  return ( list(name = nm[removeCols] , columns = removeCols )    )   
}
```

```{r}
# b is data without EFT_H and target value
b = data19[,-c(1,p) ]
mySum = function( row )
{
  return ( sum( row == 0) )
}
mid = apply(b , 2 , diff)
res = apply( mid , 1 , mySum )
for ( values in c(44:55) )
{
index = which( res <= values )
cat("with counting:",values, "size of data is:",length( index ),"\n" )
}
### choose counting 48, largest gap
index = which( res <= 46 )
filterData = data19[index, ]
```

### Start recursive
```{r}
dataVif = vifSelection( train , vifThres = 15)
dataVif$name
removeCols = (dataVif$columns)[-1]
filterData = train[,-removeCols]
```
```{r}
imp = read.csv(file.choose(), header = TRUE) 
imp$variables
ph_group =vifSelection( data = select( train, pH.at.stn1,pH.at.stn3,pH.at.stn5,interpolated_acetic), vifThres = 10  )
ph_group$name

methane_group = vifSelection( data = train[,c(20:24,p)], vifThres = 10  )
methane_group$name

ratio_group = vifSelection( data = train[,c(64:68,p)], vifThres = 10  )
ratio_group$name

o2_group = vifSelection( data = train[,c(25:29,p)], vifThres = 10  )
o2_group$name

Do_group = vifSelection( data = train[,c(15:19,p)], vifThres = 10  )
Do_group$name

filter_data = select( train , -c(ph_group$name , methane_group$name , ratio_group$name ,o2_group$name , Do_group$name))
dataVif = vifSelection( filter_data , vifThres = 10)
dataVif$name
```

### forward adding
```{r}
#imp is the  output csv of the final_weights
imp = read.csv(file.choose(),header = TRUE)
# colnames(imp) = c("variables","weights")
forward_selection = function( train ,imp , auto = FALSE, delete_thres = 15 , remain_thres = 5)
{
  target_index = ncol(train)
  nm = names(train)
  p = nrow(imp)
  start_inputs = imp$variables[1:2]
  max_vif = rep(0,2)
  mean_vif = rep(0,2)
  inputs = c(which( nm == start_inputs[1] ) , which( nm == start_inputs[2] ) )
  reg = lm( interpolated_acetic~., train[,c(inputs,target_index)] )
  prev_vif = round( vif(reg) , 2)
  run = 0
  
  for ( col in 3: p )
  {
    run = run+1
    variable = imp$variables[col]
    cat("this is run:",run,"--------------------------------- \n")
    cat("going to add variable:",variable,"\n")
    cat("\n")
    inputs = c(inputs , which( nm == variable ) )
    reg = lm( interpolated_acetic~., train[,c(inputs,target_index)] )
    vif_value = round( vif(reg) , 2)
    current_index = length( vif_value )
    cat("if we add variable variable:", variable,", the top largest VIFs are:\n")
    print( vif_value[ c( order( vif_value, decreasing = TRUE )[1:3] ) ] )
    cat("\n")
    cat("the current variable's VIF is ", vif_value[current_index] , "\n")
    
    vif_change = vif_value[ - current_index ] - prev_vif
    if ( max(vif_change) > delete_thres | vif_value[current_index] > delete_thres )
    {
      cat("it brings too much,", variable,"automatically deleted \n")
      inputs = inputs[- current_index ]
      reg = lm( interpolated_acetic~., train[,c(inputs,target_index)] )
      prev_vif = vif( reg )
      next
    }
      if ( max(vif_change) < remain_thres  )
    {
      cat("it doesn't bring a lot,", variable,"automatically added \n")
      prev_vif = vif_value
      next
      }
    
    cat("it brings the changes of VIFs(top 3):  \n")
    print( vif_change[ order( vif_change, decreasing = TRUE )[1:3]] )
    if (max(vif_value) < 10)
    {
      cat("chosed to add:",variable,"\n")
      cat("no need for deletion \n")
      cat("--------------------------------\n")
      prev_vif = vif_value
      next
    }
    deleted = readline(prompt="enter the delte variables: 1 is delete, 0 is not deleted \n")
    if ( deleted == "1")
    {
      inputs = inputs[- length(inputs) ]
      reg = lm( interpolated_acetic~., train[,c(inputs,target_index)] )
      prev_vif = vif( reg )
    } 
    else if (deleted == "q")
    {
      cat("quit \n")
      break
    }
    else if (deleted == "0")
    {
      cat("chose to add:",variable,"\n")
      prev_vif = vif_value
      next
    }
    else if( deleted != '0')
    {
      index = which( nm == deleted )
      inputs = inputs[ - which(inputs == index)  ]
      reg = lm( interpolated_acetic~., train[,c(inputs,target_index)] )
      prev_vif = vif( reg )
    }
    else
    {
      next
    }
  }
  return (inputs)
}
```

```{r}
inputs = forward_selection( denoise_combine , imp )
```

```{r}
nm = names(denoise_combine)
res = c()
for (name in nm)
{
  index = which(imp$variables==name)
  if (length(index) == 0)
  {
    res = c(res,name)
  }
  print(index)

}
```


```{r}
new = inputs[1]
for ( element in inputs[-1])
  new = paste(new, element, sep = ',')

index5 = c(64,55,1,56,23,21,2,10,25,41,63,61,57,22,60,27,13,3,11,46,14,4,6,5,44,59,12,47,28,7,26,33,36,38,35,34,40,62,39,52,42,51,32,37,65)
index3 = c(66,57,58,50,23,25,65,27,59,63,1,43,29,24,2,62,15,12,46,13,3,16,61,8,28,40,14,35,30,10,4,49,54,5,9,41,53,64,34,37,36,42,39,44,38)

index1 = c(53,65,30,28,21,3,32,25,18,46,27,16,49,48,15,51,19,5,31,11,38,43,6,68,44,33,4,2,52,17,13,10,9,14,66,12,63,7,8,45,40,50,39,37,64,42,47,41)

index2 = c(53,65,30,28,3,32,18,46,27,20,16,49,19,5,31,11,38,43,6,68,44,33,4,2,52,17,13,66,12,63,7,45,40,50,39,37,64,42,47,41)
```


```{r}
subset_cols = c(53,65,30,28,21,3,32,25,18,46,27,16,49,48,15,51,19,5,31,11,38,43,6,68,44,33,4,2,52,17,13,10,9,14,66,12,63,7,8,45,40,50,39,37,64,42,47,41)
library(DiagrammeR)
xgbLinear = modelTrain(  data = train[,c(1,subset_cols,ncol(train))], 
                          method = "xgbLinear", 
                          trControl = fitControl,
                          tuneGrid = NULL,
                          tuneLength = tuneLength,
                          cpu = cpu, 
                          test = test
                )
```

```{r}
xgbLinear$RMSE
varImp(xgbLinear$model)
tree_plot = xgb.plot.tree(model = xgbLinear$model$finalModel,tree = 1 , render = FALSE)
export_graph(tree_plot, "xbgLinear.pdf", width = 10000, height = 15000)
```


















```{r}
repeats = 2
folds = 5
total = repeats * folds 
result = c()
lambdaSearch = seq( 0, 5 , length.out = 100) 
lambdaSearch[2] = 1e-5
alphaSearch = seq(0,1,10)
seeds = vector(mode = "list", length = total+1)
for(i in 1:total) seeds[[i]]= sample.int(n=1000, 15 )
seeds[[ (total+1) ]]=sample.int(1000, 1)
fitControl = trainControl( method = "repeatedcv", number = folds, repeats = repeats , search = "random" ,seed = seeds)
```


```{r}
preProcess = c( "center ")
lambdaSearch = seq( 0, 0.5 , length.out = 50) 
lambdaSearch[2] = 1e-5
set.seed(825)
lassoGrid = expand.grid( lambda = lambdaSearch , alpha = 0)
lasso = train( interpolated_acetic~ . -EFT_H , 
               data = filterData2, 
               method = "glmnet", 
               trControl = fitControl,
               tuneGrid = lassoGrid,
               tuneLength = 2,
               preProcess = #c("center")
              )

plot(lasso)
coef(lasso$finalModel, s = lasso$bestTune$lambda)
```

